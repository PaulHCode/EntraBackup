# Azure Functions profile.ps1
#
# This profile.ps1 will get executed every "cold start" of your Function App.
# "cold start" occurs when:
#
# * A Function App starts up for the very first time
# * A Function App starts up after being de-allocated due to inactivity
#

switch ($env:website_hostname.split('.')[-1]) {
    'net' {
        Set-Variable -Name ResourceManagerUrl -Value 'https://management.azure.com' -Option Constant
        Set-Variable -Name MicrosoftGraphUrl -Value 'https://graph.microsoft.com' -Option Constant
        Set-Variable -Name StorageTokenUrl -Value 'https://storage.azure.com' -Option Constant
        Set-Variable -Name StorageResourceUrl -Value 'https://storage.azure.com' -Option Constant
    }
    'us' {
        Set-Variable -Name ResourceManagerUrl -Value 'https://management.usgovcloudapi.net' -Option Constant
        Set-Variable -Name MicrosoftGraphUrl -Value 'https://graph.microsoft.us' -Option Constant
        Set-Variable -Name StorageTokenUrl -Value 'https://storage.azure.com' -Option Constant
        Set-Variable -Name StorageResourceUrl -Value 'https://storage.usgovcloudapi.net' -Option Constant
        Set-Variable -Name LoginUrl -Value 'https://login.microsoftonline.us' -Option Constant
    }
    default {
        Write-Error 'Unknown Azure Cloud'
    }
}
If ($env:debug -eq 'true') {
    $ErrorActionPreference = 'Continue'
    $WarningPreference = 'Continue'
    $VerbosePreference = 'Continue'
    $InformationPreference = 'Continue'
    $DebugPreference = 'SilentlyContinue'
    $ProgressPreference = 'Continue'
    $LogCommandHealthEvent = $false
    $LogCommandLifecycleEvent = $false
    $LogEngineHealthEvent = $true
    $LogEngineLifecycleEvent = $true
    $LogProviderHealthEvent = $true
    $LogProviderLifecycleEvent = $true
    $MaximumHistoryCount = 4096
    $PSDefaultParameterValues = @{
        "*:Verbose"           = $true
        "*:ErrorAction"       = 'Continue'
        "*:WarningAction"     = 'Continue'
        "*:InformationAction" = 'SilentlyContinue'
    }
}
Else {
    $ErrorActionPreference = 'SilentlyContinue'
    $WarningPreference = 'SilentlyContinue'
    $VerbosePreference = 'SilentlyContinue'
    $InformationPreference = 'SilentlyContinue'
    $DebugPreference = 'SilentlyContinue'
    $ProgressPreference = 'SilentlyContinue'
    $LogCommandHealthEvent = $false
    $LogCommandLifecycleEvent = $false
    $LogEngineHealthEvent = $false
    $LogEngineLifecycleEvent = $false
    $LogProviderHealthEvent = $false
    $LogProviderLifecycleEvent = $false
    $MaximumHistoryCount = 1
    $PSDefaultParameterValues = @{
        "*:Verbose"           = $false
        "*:ErrorAction"       = 'SilentlyContinue'
        "*:WarningAction"     = 'SilentlyContinue'
        "*:InformationAction" = 'SilentlyContinue'
    }
}

Function Invoke-AzureRestMethod {
    <#
        .SYNOPSIS
            Run an Azure REST call.
        .DESCRIPTION
            This is a modified version of Daniel Chronlund's Invoke-DCMsGraphQuery function. It will run a query against Microsoft REST APIs and return the result. It will connect using an access token generated by Connect-DCMsGraphAsDelegated or Connect-DCMsGraphAsApplication (depending on what permissions you use in Graph).
            This CMDlet will run a query against Microsoft REST APIs and return the result. It will connect using an access token generated by Connect-DCMsGraphAsDelegated or Connect-DCMsGraphAsApplication (depending on what permissions you use in Graph).
            Before running this CMDlet, you first need to register a new application in your Azure AD according to this article:
            https://danielchronlund.com/2018/11/19/fetch-data-from-microsoft-graph-with-powershell-paging-support/

        .PARAMETER AccessToken
                An access token generated by Connect-DCMsGraphAsDelegated or Connect-DCMsGraphAsApplication (depending on what permissions you use in Graph).
        .PARAMETER Method
                The HTTP method for the Graph call, like GET, POST, PUT, PATCH, DELETE. Default is GET.
        .PARAMETER Uri
                The Microsoft Graph URI for the query. Example: https://graph.microsoft.com/v1.0/users/
        .PARAMETER Body
                The request body of the Graph call. This is often used with methids like POST, PUT and PATCH. It is not used with GET.

        .INPUTS
            None
        .OUTPUTS
            None
        .NOTES
            Author:   Daniel Chronlund
            GitHub:   https://github.com/DanielChronlund/DCToolbox
            Blog:     https://danielchronlund.com/

        .EXAMPLE
            Invoke-AzureRestMethod -AccessToken $AccessToken -Method 'GET' -Uri 'https://graph.microsoft.com/v1.0/users/'
    #>

    param (
        [parameter(Mandatory = $true)]
        [string]$AccessToken,

        [parameter(Mandatory = $false)]
        [string]$Method = 'GET',

        [parameter(Mandatory = $true)]
        [string]$Uri,

        [parameter(Mandatory = $false)]
        [string]$Body = '',

        [parameter(Mandatory = $false)]
        [hashtable]$AdditionalHeaders
    )

    # Check if authentication was successfull.
    if ($AccessToken) {
        # Format headers.
        $HeaderParams = @{
            'Content-Type'  = "application\json"
            'Authorization' = "Bearer $AccessToken"
        }
        If ($AdditionalHeaders) {
            $HeaderParams += $AdditionalHeaders
        }

        # Create an empty array to store the result.
        $QueryRequest = @()
        $dataToUpload = @()

        # Run the first query.
        if ($Method -eq 'GET') {
            $QueryRequest = Invoke-RestMethod -Headers $HeaderParams -Uri $Uri -UseBasicParsing -Method $Method -ContentType "application/json" -Verbose:$false
        }
        else {
            $QueryRequest = Invoke-RestMethod -Headers $HeaderParams -Uri $Uri -UseBasicParsing -Method $Method -ContentType "application/json" -Body $Body -Verbose:$false
        }
        if ($QueryRequest.value) {
            $dataToUpload += $QueryRequest.value
        }
        else {
            $dataToUpload += $QueryRequest
        }

        # Invoke REST methods and fetch data until there are no pages left.
        if ($Uri -notlike "*`$top*") {
            while ($QueryRequest.'@odata.nextLink' -and $QueryRequest.'@odata.nextLink' -is [string]) {
                $QueryRequest = Invoke-RestMethod -Headers $HeaderParams -Uri $QueryRequest.'@odata.nextLink' -UseBasicParsing -Method $Method -ContentType "application/json" -Verbose:$false
                $dataToUpload += $QueryRequest.value
            }
            While ($QueryRequest.nextLink -and $QueryRequest.nextLink -is [string]) {
                $QueryRequest = Invoke-RestMethod -Headers $HeaderParams -Uri $QueryRequest.'nextLink' -UseBasicParsing -Method $Method -ContentType "application/json" -Verbose:$false #4>$null
                $dataToUpload += $QueryRequest.value
            }
            While ($QueryRequest.'$skipToken' -and $QueryRequest.'$skipToken' -is [string] -and $Body -ne '') {
                $tempBody = $Body | ConvertFrom-Json -AsHashtable
                $tempBody.'$skipToken' = $QueryRequest.'$skipToken'
                $Body = $tempBody | ConvertTo-Json -Depth 99
                $QueryRequest = Invoke-RestMethod -Headers $HeaderParams -Uri $Uri -UseBasicParsing -Method $Method -ContentType "application/json" -Body $Body -Verbose:$false #4>$null
                $dataToUpload += $QueryRequest.data
            }
        }
        $dataToUpload
    }
    else {
        Write-Error "No Access Token"
    }
}

function Connect-AcquireToken {
    <#
    .SYNOPSIS
    Connects to Azure AD and acquires an access token for the specified token resource URL.

    .DESCRIPTION
    The Connect-AcquireToken function connects to Azure AD and acquires an access token for the specified token resource URL. It supports both managed identity and service principal authentication methods.

    .PARAMETER ResourceManagerUrl
    The URL of the token resource for which to acquire the access token. The default value is $MicrosoftGraphUrl.

    .EXAMPLE
    Connect-AcquireToken -ResourceManagerUrl "https://graph.microsoft.com"
    This example connects to Azure AD and acquires an access token for the Microsoft Graph API.

    .INPUTS
    None

    .OUTPUTS
    System.String

    .NOTES
    This function requires the Azure PowerShell module to be installed.

    .LINK
    https://docs.microsoft.com/en-us/powershell/azure/new-azureps-module-az?view=azps-12.0.0
    #>
    [CmdletBinding()]
    param (
        [string]$tokenResourceURL = $MicrosoftGraphUrl
    )

    if ($env:MSI_ENDPOINT) {
        return Connect-AcquireTokenViaManagedIdentity -ResourceManagerUrl $tokenResourceURL
    }
    Else {
        Write-Verbose "No Managed Identity - Getting test token"
        return (Get-AzAccessToken -ResourceUrl $tokenResourceURL).token
    }

    #return Connect-AcquireTokenViaServicePrincipal -ResourceManagerUrl $ResourceManagerUrl
}

function Connect-AcquireTokenViaManagedIdentity {
    [CmdletBinding()]
    param (
        [string]$ResourceManagerUrl = $MicrosoftGraphUrl
    )
    $endpoint = $env:MSI_ENDPOINT
    $secret = $env:MSI_SECRET
    
    $accessTokenHeader = @{
        Secret = $secret
    }
    $OAuthUri = "$($endpoint)?api-version=2017-09-01&resource=$($ResourceManagerUrl)"
    
    $OAuth = Invoke-RestMethod -Method Get -Uri $OAuthUri -Headers $accessTokenHeader

    # Return the access token.
    $OAuth.access_token
}

function Upload-ToBlob {
    [CmdletBinding()]
    param(
        [parameter(Mandatory = $true)]
        [string]
        $ConnectionStringURI,
        [parameter(Mandatory = $false)]
        [string]
        $Path = {
            $myUTC = ([datetime]::UtcNow).tostring('yyyy-MM-ddTHH:mm:ss')
            $tzUTC = [system.timezoneinfo]::GetSystemTimeZones() | Where-Object { $_.id -eq 'UTC' }
            $tzEST = [system.timezoneinfo]::GetSystemTimeZones() | Where-Object { $_.id -eq 'US Eastern Standard Time' }
            $now = [System.TimeZoneInfo]::ConvertTime($myUTC, $tzUTC, $tzEST)
            "y=$($now.tostring('yyyy'))/m=$($now.tostring('MM'))/d=$($now.tostring('dd'))/h=$($now.tostring('HH'))/m=$($now.tostring('mm'))"
        },
        [parameter(Mandatory = $true)]
        [ValidateNotNullOrEmpty()]
        [string]
        $filename,
        [parameter(Mandatory = $false)]
        [string]
        $timestamp = [datetime]::UtcNow.tostring('yyyy-MM-dd_HHmmss'),
        [parameter(Mandatory = $false)]
        $dataToUpload = '',
        [parameter(Mandatory = $false)]
        $infile = '',
        [parameter(Mandatory = $true)]
        [ValidateNotNullOrEmpty()]
        [string]
        $storageToken,
        [parameter(Mandatory = $false)]
        [ValidateSet('json', 'csv', 'zip', 'txt')]
        [string]
        $extension = 'json',
        [parameter(Mandatory = $false)]
        [hashtable]
        $metadata
    )
    If ([string]::IsNullOrEmpty($dataToUpload)) { $dataToUpload = ' ' }
    $blobname = If ([string]::IsNullOrEmpty($Path)) { "$($filename)_$timestamp.$extension" }Else { "$Path/$($filename)_$timestamp.$extension" }
    $filestring = "$($timestamp)_$filename.$extension"
    
    If ([string]::IsNullOrEmpty($storageToken)) {
        $storageToken = Connect-AcquireToken -TokenResourceUrl $StorageTokenUrl
    }
    If ([string]::IsNullOrEmpty($storageToken)) {
        Write-Error "No Storage Token even after trying to get it"
    }

    If ($extension -eq 'csv') {
        $ContentType = 'text/csv; charset=UTF-8'
        If ([string]::IsNullOrEmpty($dataToUpload)) {
            Write-Warning "No results - so no CSV created"
        }
        Else {
            $body = ($dataToUpload | ConvertTo-Csv -NoTypeInformation) -join "`n"
        }
    }
    ElseIf ($extension -eq 'txt') {
        $ContentType = 'text/plain; charset=UTF-8'
        If ([string]::IsNullOrEmpty($dataToUpload)) {
            Write-Warning "No results - so no txt file created."
        }
        Else {
            $body = $dataToUpload
        }

    }
    ElseIf ($extension -eq 'zip') {
        $ContentType = 'application/zip'
        $body = $dataToUpload
    }
    Else {
        $ContentType = 'application/json; charset=UTF-8'
        $body = $dataToUpload | ConvertTo-Json -Depth 99
    }
    #Upload to storage 
    Write-Verbose -Message "$filename : Uploading $filestring to $ConnectionStringURI" -Verbose:$VerbosePreference
    $ConnectionStringAll = $ConnectionStringURI + "/" + $blobname
    $headers = @{
        'Content-Type'   = $ContentType
        'x-ms-blob-type' = 'BlockBlob'
        'authorization'  = "Bearer $storageToken"
        'x-ms-version'   = '2020-04-08'
        'x-ms-date'      = $([datetime]::UtcNow.tostring('ddd, dd MMM yyyy HH:mm:ss ') + 'GMT')
    } 

    If ($infile) {
        $body = [System.IO.File]::ReadAllBytes($infile)
        $headers.Remove('Content-Type')
        $headers.Add('Content-Length', $body.Length)
        $Null = Invoke-WebRequest -Uri $ConnectionStringAll -Method PUT -Headers $headers -Body $body -InFile $infile -UseBasicParsing
    }
    Else {
        $Null = Invoke-WebRequest -Uri $ConnectionStringAll -Method PUT -Headers $headers -Body $body -ContentType $ContentType -UseBasicParsing
    }
}

Function Get-ResourceGroupREST {
    [CmdletBinding()]
    param (
        [parameter(Mandatory = $true)]
        [string]$SubscriptionId,
        [parameter(Mandatory = $false)]
        [string]$ResourceGroupName
    )

    $resourceManagerToken = Connect-AcquireToken -TokenResourceUrl $ResourceManagerUrl
    #$resourceManagerToken = (Get-AzAccessToken -ResourceUrl $ResourceManagerUrl).token
    If ($ResourceGroupName) {
        $uri = "$resourceManagerUrl/subscriptions/$SubscriptionId/resourceGroups/$($ResourceGroupName)?api-version=2014-04"
    }
    Else {
        $uri = "$resourceManagerUrl/subscriptions/$SubscriptionId/resourceGroups?api-version=2014-04"
    }
    #    $uri = "$resourceManagerUrl/subscriptions/$SubscriptionId/resourceGroups/$($ResourceGroupName)?api-version=2014-04"
    $resourceGroup = Invoke-AzureRestMethod -AccessToken $resourceManagerToken -Uri $uri -Method Get
    $resourceGroup
}

Function Get-SubscriptionsREST {
    [CmdletBinding()]
    param ()

    $resourceManagerToken = Connect-AcquireToken -TokenResourceUrl $ResourceManagerUrl
    #$resourceManagerToken = (Get-AzAccessToken -ResourceUrl $ResourceManagerUrl).token
    $uri = "$resourceManagerUrl/subscriptions?api-version=2016-06-01"
    $subscriptions = Invoke-AzureRestMethod -AccessToken $resourceManagerToken -Uri $uri -Method Get
    $subscriptions
}

Function Get-ResourcesREST {
    [CmdletBinding()]
    param (
        [parameter(Mandatory = $true)]
        [string]$SubscriptionId,
        [parameter(Mandatory = $false)]
        [string]$ResourceGroupName
    )

    $resourceManagerToken = Connect-AcquireToken -TokenResourceUrl $ResourceManagerUrl
    #$resourceManagerToken = (Get-AzAccessToken -ResourceUrl $ResourceManagerUrl).token
    If ($ResourceGroupName) {
        $uri = "$resourceManagerUrl/subscriptions/$SubscriptionId/resourceGroups/$($ResourceGroupName)/resources?api-version=2016-09-01"
    }
    Else {
        $uri = "$resourceManagerUrl/subscriptions/$SubscriptionId/resources?api-version=2016-09-01"
    }
    $resources = Invoke-AzureRestMethod -AccessToken $resourceManagerToken -Uri $uri -Method Get
    $resources
}

function Get-RoleAssignmentsREST {
    [CmdletBinding()]
    param (
        [parameter(Mandatory = $true)]
        [string]$SubscriptionId,
        [parameter(Mandatory = $false)]
        [string]$ResourceGroupName
    )

    $resourceManagerToken = Connect-AcquireToken -TokenResourceUrl $ResourceManagerUrl
    #$resourceManagerToken = (Get-AzAccessToken -ResourceUrl $ResourceManagerUrl).token
    If ($ResourceGroupName) {
        $uri = "$resourceManagerUrl/subscriptions/$SubscriptionId/resourceGroups/$($ResourceGroupName)/providers/Microsoft.Authorization/roleAssignments?api-version=2022-04-01"
    }
    Else {
        $uri = "$resourceManagerUrl/subscriptions/$SubscriptionId/providers/Microsoft.Authorization/roleAssignments?api-version=2015-07-01"
    }
    $roleAssignments = Invoke-AzureRestMethod -AccessToken $resourceManagerToken -Uri $uri -Method Get
    $roleAssignments
}

Function Get-TemplateForResourcesREST {
    [CmdletBinding()]
    param (
        [parameter(Mandatory = $true)]
        [string]$SubscriptionId,
        [parameter(Mandatory = $true)]
        [string]$ResourceGroupName,
        [parameter(Mandatory = $false)]
        [array]$Resources
    )

    $resourceManagerToken = Connect-AcquireToken -TokenResourceUrl $ResourceManagerUrl
    #$resourceManagerToken = (Get-AzAccessToken -ResourceUrl $ResourceManagerUrl).token
    If ($Resources -eq $null) {
        $Resources = @('*')
    }
    
    $body = @{
        options   = 'IncludeParameterDefaultValue'
        resources = $Resources
    } | ConvertTo-Json
    $uri = "$resourceManagerUrl/subscriptions/$SubscriptionId/resourcegroups/$ResourceGroupName/exportTemplate?api-version=2018-08-01"
    $template = Invoke-AzureRestMethod -Uri $uri -Method Post -Body $body -AccessToken $resourceManagerToken   
    $template
}

#Functions to write
# Backup Users
Function Get-EntraUsersREST {
    [CmdletBinding()]
    param (
    )

    $microsoftGraphToken = Connect-AcquireToken -TokenResourceUrl $MicrosoftGraphUrl
    #$microsoftGraphToken = (Get-AzAccessToken -ResourceUrl $MicrosoftGraphUrl).token
    $url = "$MicrosoftGraphUrl/v1.0/users"
    $users = Invoke-AzureRestMethod -AccessToken $microsoftGraphToken -Uri $url -Method Get -AdditionalHeaders @{'ConsistencyLevel' = 'eventual' }
    $count = 0
    ForEach ($user in $users | Select-Object) {
        Write-Verbose "working on user $count of $($users.count)"
        $count++
        [pscustomobject]@{
            user                 = $user
            EntraRoleAssignments = Get-EntraRoleAssignmentsREST -UserId $user.id
            GroupMembership      = Get-EntraGroupMembershipREST -UserId $user.id
            #RBACRoleAssignments = Get-RoleRBACRolesAssignmentsREST -UserId $user.id
        }
    }
}
#Get Entra role assignments for a user or group
Function Get-EntraRoleAssignmentsREST {
    [CmdletBinding()]
    param (
        [parameter(Mandatory = $true, ParameterSetName = 'User')]
        [string]$UserId,
        [parameter(Mandatory = $true, ParameterSetName = 'Group')]
        [string]$GroupId
    )

    $microsoftGraphToken = Connect-AcquireToken -TokenResourceUrl $MicrosoftGraphUrl
    #$microsoftGraphToken = (Get-AzAccessToken -ResourceUrl $MicrosoftGraphUrl).token
    If ($UserId) {
        $url = "$MicrosoftGraphUrl/beta/RoleManagement/directory/roleAssignments?`$count=true&`$filter=principalId eq '$UserId'"
        #$url = "$MicrosoftGraphUrl/v1.0/users/$UserId/directoryRoleAssignments"
    }
    ElseIf ($GroupId) {
        $url = "$MicrosoftGraphUrl/beta/RoleManagement/directory/roleAssignments?`$count=true&`$filter=principalId eq '$GroupId'"
        #$url = "$MicrosoftGraphUrl/v1.0/groups/$GroupId/directoryRoleAssignments"
    }
    $roleAssignments = Invoke-AzureRestMethod -AccessToken $microsoftGraphToken -Uri $url -Method Get -AdditionalHeaders @{'ConsistencyLevel' = 'eventual' }
    [array]$roleAssignments
}

Function Get-EntraGroupMembershipREST {
    [CmdletBinding()]
    param (
        [parameter(Mandatory = $true, ParameterSetName = 'User')]
        [string]$UserId,
        [parameter(Mandatory = $true, ParameterSetName = 'Group')]
        [string]$GroupId
    )
    $microsoftGraphToken = Connect-AcquireToken -TokenResourceUrl $MicrosoftGraphUrl
    #$microsoftGraphToken = (Get-AzAccessToken -ResourceUrl $MicrosoftGraphUrl).token
    If ($UserId) {
        $url = "$MicrosoftGraphUrl/v1.0/users/$UserId/memberOf"
    }
    ElseIf ($GroupId) {
        $url = "$MicrosoftGraphUrl/v1.0/groups/$GroupId/memberOf"
    }
    #    $url = "$MicrosoftGraphUrl/v1.0/users/$UserId/MemberOf"
    $groupMembership = Invoke-AzureRestMethod -AccessToken $microsoftGraphToken -Uri $url -Method Get -AdditionalHeaders @{'ConsistencyLevel' = 'eventual' }
    [array]$groupMembership
}

# Backup Groups
Function Get-EntraGroupsREST {
    [CmdletBinding()]
    param (
    )

    $microsoftGraphToken = Connect-AcquireToken -TokenResourceUrl $MicrosoftGraphUrl
    #$microsoftGraphToken = (Get-AzAccessToken -ResourceUrl $MicrosoftGraphUrl).token
    $url = "$MicrosoftGraphUrl/v1.0/groups"
    $groups = Invoke-AzureRestMethod -AccessToken $microsoftGraphToken -Uri $url -Method Get -AdditionalHeaders @{'ConsistencyLevel' = 'eventual' }
    $count = 0
    $EntraGroups = forEach ($group in $groups | Select-Object) {
        Write-Verbose "working on group $count of $($groups.count)"
        $count++
        [pscustomobject]@{
            group                = $group
            GroupMembership      = [array]$(Get-EntraGroupMembershipREST -GroupId $group.id)
            EntraRoleAssignments = [array]$(Get-EntraRoleAssignmentsREST -GroupId $group.id)
        }
    }
    [array]$EntraGroups
}
# Backup Roles
Function Get-EntraRolesREST {
    [CmdletBinding()]
    param (
    )

    $microsoftGraphToken = Connect-AcquireToken -TokenResourceUrl $MicrosoftGraphUrl
    #$microsoftGraphToken = (Get-AzAccessToken -ResourceUrl $MicrosoftGraphUrl).token
    $url = "$MicrosoftGraphUrl/v1.0/directoryRoles"
    $roles = Invoke-AzureRestMethod -AccessToken $microsoftGraphToken -Uri $url -Method Get -AdditionalHeaders @{'ConsistencyLevel' = 'eventual' }
    [array]$roles
}
# Backup Conditional Access Policies
# Backup Named Locations
# Backup Service Principals
# Backups permissions for all resources/Resource Groups/Subscription/Management Group
# 

Function Restore-ObjectREST {
    [CmdletBinding()]
    param (
        [parameter(Mandatory = $true)]
        $objectToRestore
    )
    switch (Get-RestoreObjectType -objectToRestore $objectToRestore) {
        'user' {
            Restore-UserREST -objectToRestore $objectToRestore
        }
        'group' {
            Restore-GroupREST -objectToRestore $objectToRestore
        }
    }
    <#
    $resourceManagerToken = Connect-AcquireToken -TokenResourceUrl $ResourceManagerUrl
    #$resourceManagerToken = (Get-AzAccessToken -ResourceUrl $ResourceManagerUrl).token
    $subscriptionId = $objectToRestore.resourceGroup.id.Split('/')[2]
    $resourceGroupName = $objectToRestore.resourceGroup.Name

    $body = @{
        'properties' = @{
            'mode'     = 'Incremental'
            'template' = $objectToRestore.template
        }
    } | ConvertTo-Json -Depth 99

    $deploymentId = [guid]::NewGuid().ToString()
    Write-Host "Attempting Deployment $deploymentId `t SubscriptionId: $subscriptionId `t ResourceGroupName: $resourceGroupName" -ForegroundColor Green
    $uri = "$resourceManagerUrl/subscriptions/$subscriptionId/resourcegroups/$resourceGroupName/providers/Microsoft.Resources/deployments/$($deploymentId)?api-version=2020-10-01"
    $response = Invoke-AzureRestMethod -Uri $uri -Method Put -Body $body -AccessToken $resourceManagerToken
    Write-Host "Created Deployment $($response.id)" -ForegroundColor Green
    #>
}

Function Restore-UserREST {
    [CmdletBinding()]
    param (
        [parameter(Mandatory = $true)]
        $objectToRestore
    )
    #Restore the user object
    $restoreUserObjectResult = Restore-UserObjectREST -objectToRestore $objectToRestore
    Write-Verbose "Restoring user $($objectToRestore.user.userPrincipalName) - $($objectToRestore.user.id) - Result: $restoreUserObjectResult"
    #Restore additional user properties
    #to do later
    
    If ($restoreUserObjectResult) {
        # The user object was restored successfully, so it has a new ID
        $servicePrincipalId = $restoreUserObjectResult.id
    }
    Else {
        # The user object was not restored, so we will use the original ID
        $servicePrincipalId = $objectToRestore.user.id
    }
    
    #Restore the User Entra Role Assignments
    $restoreEntraRoleAssignmentResults = Restore-EntraRoleAssignmentsREST -ServicePrincipalId $servicePrincipalId -roleAssignments $objectToRestore.EntraRoleAssignments
    Write-Verbose "Restoring Entra Role Assignments for user $($objectToRestore.user.userPrincipalName) - $servicePrincipalId - Result: $($restoreEntraRoleAssignmentResults.count) assignments restored"
    #Restore the User Group Memberships
    $restoreEntraGroupMembershipsResults = Restore-EntraGroupMembershipsREST -ServicePrincipalId $servicePrincipalId -groupMemberships $objectToRestore.GroupMembership
    Write-Verbose "Restoring Entra Group Memberships for user $($objectToRestore.user.userPrincipalName) - $servicePrincipalId - Result: $($restoreEntraGroupMembershipsResults.count) memberships restored"
}

Function Restore-EntraRoleAssignmentsREST {
    [CmdletBinding()]
    param (
        [parameter(Mandatory = $true)]
        [string]$ServicePrincipalId,
        [parameter(Mandatory = $true)]
        [array]$roleAssignments
    )

    $microsoftGraphToken = Connect-AcquireToken -TokenResourceUrl $MicrosoftGraphUrl
    #$microsoftGraphToken = (Get-AzAccessToken -ResourceUrl $MicrosoftGraphUrl).token
    ForEach ($roleAssignment in $roleAssignments) {
        $url = "$MicrosoftGraphUrl/beta/RoleManagement/directory/roleAssignments"
        $body = @{
            '@odata.type'      = '#microsoft.graph.unifiedRoleAssignment'
            'principalId'      = $ServicePrincipalId
            'roleDefinitionId' = $roleAssignment.roleDefinitionId
            'directoryScopeId' = $roleAssignment.directoryScopeId
        } | ConvertTo-Json -Depth 99
        $response = Invoke-AzureRestMethod -AccessToken $microsoftGraphToken -Uri $url -Method Post -Body $body
        $response
    }
}

Function Restore-EntraGroupMembershipsREST {
    [CmdletBinding()]
    param (
        [parameter(Mandatory = $true)]
        [string]$ServicePrincipalId,
        [parameter(Mandatory = $true)]
        [array]$groupMemberships
    )

    $microsoftGraphToken = Connect-AcquireToken -TokenResourceUrl $MicrosoftGraphUrl
    #$microsoftGraphToken = (Get-AzAccessToken -ResourceUrl $MicrosoftGraphUrl).token
    ForEach ($groupMembership in $groupMemberships | Where-Object { $_.'@odata.type' -eq '#microsoft.graph.group' }) {
        $url = "$MicrosoftGraphUrl/v1.0/groups/$($groupMembership.id)/members/`$ref"#/members/$ServicePrincipalId
        $body = @{
            '@odata.id' = "$MicrosoftGraphUrl/v1.0/directoryObjects/$ServicePrincipalId"
        } | ConvertTo-Json -Depth 99
        $response = Invoke-AzureRestMethod -AccessToken $microsoftGraphToken -Uri $url -Method Post -Body $body
        $response
    }
}

Function Restore-UserObjectREST {
    [CmdletBinding()]
    param (
        [parameter(Mandatory = $true)]
        $objectToRestore
    )
    $microsoftGraphToken = Connect-AcquireToken -TokenResourceUrl $MicrosoftGraphUrl
    #$microsoftGraphToken = (Get-AzAccessToken -ResourceUrl $MicrosoftGraphUrl).token
    #Check if the user object already exists
    $url = "$MicrosoftGraphUrl/v1.0/users/$($objectToRestore.user.id)"
    $existingUserResult = Invoke-AzureRestMethod -AccessToken $microsoftGraphToken -Uri $url -Method Get -ErrorVariable myError
    If ($existingUserResult.id) {
        <#do nothing for now
        #Update the user object
        $body = $objectToRestore.user | ConvertTo-Json -Depth 99
        $response = Invoke-AzureRestMethod -AccessToken $microsoftGraphToken -Uri $url -Method Patch -Body $body
        $response
        #>
        $null
    }
    Else {
        #Create the user object
        $url = "$MicrosoftGraphUrl/v1.0/users"
        #$body = $objectToRestore.user | ConvertTo-Json -Depth 99
        $body = @{
            'accountEnabled'    = If ($objectToRestore.user.accountEnabled) { $objectToRestore.user.accountEnabled } Else { $true }
            'mailNickname'      = If ($objectToRestore.user.mailNickname) { $objectToRestore.user.mailNickname } Else { $objectToRestore.user.userPrincipalName.Split('@')[0] }
            'displayName'       = $objectToRestore.user.displayName
            'userPrincipalName' = $objectToRestore.user.userPrincipalName
            'passwordProfile'   = @{
                'forceChangePasswordNextSignIn'        = $false #$objectToRestore.user.passwordProfile.forceChangePasswordNextSignIn
                'forceChangePasswordNextSignInWithMfa' = $false #$objectToRestore.user.passwordProfile.forceChangePasswordNextSignInWithMfa
                'password'                             = New-RandomPassword
            }
        }
        $body = $body | ConvertTo-Json -Depth 99
        $response = Invoke-AzureRestMethod -AccessToken $microsoftGraphToken -Uri $url -Method Post -Body $body
        $response
    }
    
}

Function New-RandomPassword {
    [CmdletBinding()]
    param (
        [parameter(Mandatory = $false)]
        [int]$length = 128,
        [parameter(Mandatory = $false)]
        [bool]$specialCharacters = $true,
        [parameter(Mandatory = $false)]
        [bool]$numbers = $true,
        [parameter(Mandatory = $false)]
        [bool]$lowercase = $true,
        [parameter(Mandatory = $false)]
        [bool]$uppercase = $true
    )
    $characters = @()
    If ($specialCharacters) {
        $characters += 33..47
        $characters += 58..64
        $characters += 91..96
        $characters += 123..126
    }
    If ($numbers) {
        $characters += 48..57
    }
    If ($lowercase) {
        $characters += 97..122
    }
    If ($uppercase) {
        $characters += 65..90
    }
    $password = ''
    For ($i = 0; $i -lt $length; $i++) {
        $password += [char][byte]$characters[(Get-Random -Minimum 0 -Maximum $characters.count)]
    }
    $password
}

Function Get-RestoreObjectType {
    [CmdletBinding()]
    param (
        [parameter(Mandatory = $true)]
        $objectToRestore
    )
    If ($objectToRestore.user) {
        'user'
    }
    ElseIf ($objectToRestore.group) {
        'group'
    }
}